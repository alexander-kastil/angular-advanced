# Reactive Programming with RxJS

| # | Route | Title | Teaches |
|---|-------|-------|---------|
| 1 | imperative | Imperative Reactivity | Understand the limitations of imperative programming with callbacks and mutable state. See how manual subscription management leads to memory leaks and complex control flow. |
| 2 | reactive | Declarative Reactivity | Transition to declarative reactive programming with Observables. Let RxJS handle data flow and subscriptions automatically for cleaner, more maintainable code. |
| 3 | async-pipe | Async Pipe | Use the async pipe to subscribe to Observables directly in templates. Mark components as OnPush for performance and let Angular handle subscription cleanup. |
| 4 | unsubscribe | Unsubscribing | Prevent memory leaks by properly unsubscribing from Observables. Explore patterns like takeUntil() and subscription management in component lifecycle. |
| 5 | action-streams | Action Streams | Build reactive data flows from user actions using Subject and streams. Combine multiple action streams to create responsive, event-driven applications. |
| 6 | debounced | Debounced Search | Implement efficient search with debounceTime() to reduce API calls. Combine with switchMap() to cancel previous requests when user types new queries. |
| 7 | mouse-dom | Mouse & DOM Events | Convert DOM events into Observable streams using fromEvent(). Handle mouse movements, clicks, and other browser events reactively. |
| 8 | responsive-screen | Responsive Screen | React to screen size changes and media queries using Observables. Build responsive layouts that adapt dynamically to viewport dimensions. |
| 9 | creating | Creating Observables | Create Observables from scratch using of(), from(), interval(), and custom Observable constructors. Understand cold vs hot Observables. |
| 10 | operators | Base Operators | Master fundamental operators like map(), filter(), reduce(), and forEach(). Transform and filter Observable streams with common operations. |
| 11 | transformation | Transformation | Use advanced transformation operators like flatMap(), switchMap(), and mergeMap(). Control how nested Observables are flattened into result streams. |
| 12 | err-handling | Error Handling | Handle errors in Observable streams with catchError() and retry(). Recover from failures gracefully and log errors appropriately. |
| 13 | custom-operators | Custom Operators | Build reusable custom operators with the pipe() pattern. Encapsulate complex transformation logic into composable, shareable utilities. |
